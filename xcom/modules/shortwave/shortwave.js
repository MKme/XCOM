/**
 * Shortwave Module
 * - Browse worldwide HF schedules by time ("what's on now") or by frequency.
 * - Data source is an offline snapshot generated by scripts/fetch-shortwave-schedule.js
 *
 * Note: Schedules are published in UTC. This module supports a "Local" basis to
 *       convert the query time to UTC for filtering.
 */

class ShortwaveModule {
  constructor() {
    this.view = 'time'; // 'time' | 'freq'
    this.timeBasis = 'local'; // 'local' | 'utc' (affects query interpretation + primary display)

    this.entries = [];
    this.meta = {};

    this._pendingRenderTimer = null;

    this.loadSchedule();
    this.init();
  }

  static get MAX_ROWS() { return 1500; }

  loadSchedule() {
    try {
      if (typeof shortwaveScheduleData !== 'undefined' && shortwaveScheduleData) {
        this.meta = shortwaveScheduleData.meta || {};
        this.entries = Array.isArray(shortwaveScheduleData.entries) ? shortwaveScheduleData.entries : [];
        return;
      }
    } catch (_) {
      // ignore
    }

    this.meta = {};
    this.entries = [];
  }

  init() {
    this.createModuleStructure();
    this.bindEvents();
    this.setNow();
    this.updateMeta();
    this.render();
    try { window.radioApp.updateStatus('Shortwave Broadcasts module loaded'); } catch (_) {}
  }

  createModuleStructure() {
    const moduleContainer = document.getElementById('shortwave');
    if (!moduleContainer) return;

    moduleContainer.innerHTML = `
      <div class="xModuleIntro">
        <div class="xModuleIntroTitle">What you can do here</div>
        <div class="xModuleIntroText">
          Listen to public shortwave broadcasts from around the world for situational awareness (SIGINT-style monitoring) and gather tactical context. See what's broadcasting right now, or search a frequency to find stations and schedules. Times are published in UTC, and you can view results in Local or UTC.
        </div>
      </div>
      <div class="swShell">
        <div class="swCard swCard--controls">
          <div class="swCardTitle">Shortwave Broadcasts</div>
          <div class="swCardSub">Offline snapshot of worldwide HF schedules. Always verify on-air reception.</div>

          <div class="swRow">
            <label>View</label>
            <div class="swTabs" role="tablist" aria-label="Shortwave views">
              <button type="button" class="swTab active" id="swTabTime" role="tab" aria-selected="true">By time</button>
              <button type="button" class="swTab" id="swTabFreq" role="tab" aria-selected="false">By frequency</button>
            </div>
          </div>

          <div class="swRow">
            <label for="swTimeBasis">Time basis</label>
            <div class="swGrid2">
              <select id="swTimeBasis">
                <option value="local" selected>Local time</option>
                <option value="utc">UTC</option>
              </select>
              <button type="button" id="swNowBtn" class="primary">Now</button>
            </div>
            <div class="swSmallMuted">Schedules are published in UTC; Local converts your query to UTC for filtering.</div>
          </div>

          <div class="swRow">
            <label>Query</label>
            <div class="swGrid2">
              <input type="date" id="swDate">
              <input type="time" id="swTime" step="60">
            </div>
          </div>

          <div class="swRow swForFreq" hidden>
            <label for="swFreqInput">Frequency</label>
            <input id="swFreqInput" type="text" inputmode="decimal" placeholder="e.g. 5960 kHz or 5.960 MHz">
            <div class="swGrid2">
              <div>
                <label for="swTol">Tolerance</label>
                <select id="swTol">
                  <option value="0">Exact</option>
                  <option value="0.5">±0.5 kHz</option>
                  <option value="1">±1 kHz</option>
                  <option value="2" selected>±2 kHz</option>
                  <option value="5">±5 kHz</option>
                  <option value="10">±10 kHz</option>
                </select>
              </div>
              <div class="swInline swInline--right">
                <label class="swCheck">
                  <input type="checkbox" id="swFreqOnlyActive">
                  Active only
                </label>
              </div>
            </div>
          </div>

          <div class="swRow">
            <label for="swTextFilter">Filter</label>
            <input id="swTextFilter" type="text" placeholder="station, ITU, target, remarks...">
          </div>

          <div class="swRow">
            <div class="swInline">
              <label class="swCheck">
                <input type="checkbox" id="swHideUtility" checked>
                Hide utility (-TS/-CW/-HF/...)
              </label>
            </div>
          </div>

          <div class="swDivider"></div>

          <div class="swMeta" id="swMeta"></div>
          <div class="swSmallMuted">
            Online browser: <a href="https://shortwave.live/" target="_blank" rel="noopener">shortwave.live</a> (EiBi-based)
          </div>
        </div>

        <div class="swCard swCard--results">
          <div class="swResultsTop">
            <div class="swCardTitle">Results</div>
            <div class="swSmallMuted" id="swSummary">--</div>
          </div>

          <div class="swTableWrap">
            <table class="swTable" id="swTable">
              <thead>
                <tr>
                  <th class="swColFreq">kHz</th>
                  <th class="swColTime">Time</th>
                  <th class="swColDays">Days</th>
                  <th class="swColItu">ITU</th>
                  <th>Station</th>
                  <th class="swColLang">Lang</th>
                  <th class="swColTarget">Target</th>
                  <th>Remarks</th>
                </tr>
              </thead>
              <tbody id="swTbody">
                <tr><td colspan="8" class="swEmpty">Loading…</td></tr>
              </tbody>
            </table>
          </div>
        </div>
      </div>
    `;
  }

  bindEvents() {
    const tabTime = document.getElementById('swTabTime');
    const tabFreq = document.getElementById('swTabFreq');
    const nowBtn = document.getElementById('swNowBtn');
    const basisSel = document.getElementById('swTimeBasis');
    const dateEl = document.getElementById('swDate');
    const timeEl = document.getElementById('swTime');
    const freqEl = document.getElementById('swFreqInput');
    const tolEl = document.getElementById('swTol');
    const freqOnlyEl = document.getElementById('swFreqOnlyActive');
    const textEl = document.getElementById('swTextFilter');
    const hideUtilEl = document.getElementById('swHideUtility');
    const tbody = document.getElementById('swTbody');

    if (tabTime) tabTime.addEventListener('click', () => this.setView('time'));
    if (tabFreq) tabFreq.addEventListener('click', () => this.setView('freq'));

    if (nowBtn) nowBtn.addEventListener('click', () => {
      this.setNow();
      this.render();
    });

    if (basisSel) basisSel.addEventListener('change', () => {
      this.timeBasis = basisSel.value === 'utc' ? 'utc' : 'local';
      this.render();
    });

    const schedule = () => this.scheduleRender();
    if (dateEl) dateEl.addEventListener('change', schedule);
    if (timeEl) timeEl.addEventListener('change', schedule);
    if (freqEl) freqEl.addEventListener('input', schedule);
    if (tolEl) tolEl.addEventListener('change', schedule);
    if (freqOnlyEl) freqOnlyEl.addEventListener('change', schedule);
    if (textEl) textEl.addEventListener('input', schedule);
    if (hideUtilEl) hideUtilEl.addEventListener('change', schedule);

    if (tbody) {
      tbody.addEventListener('click', (e) => {
        const tr = (e.target && e.target.closest) ? e.target.closest('tr[data-sw-row]') : null;
        if (!tr) return;
        const txt = tr.getAttribute('data-copy') || '';
        if (!txt) return;
        this.copyToClipboard(txt);
      });
    }
  }

  scheduleRender() {
    if (this._pendingRenderTimer) clearTimeout(this._pendingRenderTimer);
    this._pendingRenderTimer = setTimeout(() => {
      this._pendingRenderTimer = null;
      this.render();
    }, 120);
  }

  setView(view) {
    const v = view === 'freq' ? 'freq' : 'time';
    this.view = v;

    const tabTime = document.getElementById('swTabTime');
    const tabFreq = document.getElementById('swTabFreq');
    if (tabTime) {
      tabTime.classList.toggle('active', v === 'time');
      tabTime.setAttribute('aria-selected', v === 'time' ? 'true' : 'false');
    }
    if (tabFreq) {
      tabFreq.classList.toggle('active', v === 'freq');
      tabFreq.setAttribute('aria-selected', v === 'freq' ? 'true' : 'false');
    }

    document.querySelectorAll('#shortwave .swForFreq').forEach((el) => {
      el.hidden = v !== 'freq';
    });

    this.render();
  }

  setNow() {
    const dateEl = document.getElementById('swDate');
    const timeEl = document.getElementById('swTime');
    const basisSel = document.getElementById('swTimeBasis');
    const basis = basisSel && basisSel.value === 'utc' ? 'utc' : 'local';
    this.timeBasis = basis;

    const now = new Date();
    const parts = basis === 'utc'
      ? { y: now.getUTCFullYear(), m: now.getUTCMonth() + 1, d: now.getUTCDate(), hh: now.getUTCHours(), mm: now.getUTCMinutes() }
      : { y: now.getFullYear(), m: now.getMonth() + 1, d: now.getDate(), hh: now.getHours(), mm: now.getMinutes() };

    if (dateEl) dateEl.value = `${parts.y}-${this.pad2(parts.m)}-${this.pad2(parts.d)}`;
    if (timeEl) timeEl.value = `${this.pad2(parts.hh)}:${this.pad2(parts.mm)}`;
    if (basisSel) basisSel.value = basis;
  }

  updateMeta() {
    const metaEl = document.getElementById('swMeta');
    if (!metaEl) return;

    if (!this.entries.length) {
      metaEl.textContent = 'No schedule dataset loaded (run npm run fetch-shortwave).';
      return;
    }

    const bits = [];
    if (this.meta && this.meta.season) bits.push(String(this.meta.season));
    if (this.meta && this.meta.valid) bits.push(String(this.meta.valid));
    if (this.meta && this.meta.lastUpdate) bits.push(`Last update: ${this.meta.lastUpdate}`);
    bits.push(`${this.entries.length.toLocaleString()} entries`);
    metaEl.textContent = bits.join(' | ');
  }

  render() {
    const tbody = document.getElementById('swTbody');
    const summary = document.getElementById('swSummary');
    if (!tbody || !summary) return;

    if (!this.entries.length) {
      tbody.innerHTML = `<tr><td colspan="8" class="swEmpty">No schedule loaded. Run <code>npm run fetch-shortwave</code> to generate <code>modules/shortwave/shortwave-data.js</code>.</td></tr>`;
      summary.textContent = '0 results';
      return;
    }

    const query = this.getQueryInstant();
    if (!query) {
      tbody.innerHTML = `<tr><td colspan="8" class="swEmpty">Select a query date/time.</td></tr>`;
      summary.textContent = '0 results';
      return;
    }

    const text = (this.getValue('swTextFilter') || '').trim().toLowerCase();
    const hideUtil = this.getChecked('swHideUtility');

    let results = [];
    if (this.view === 'freq') {
      const freqQuery = this.parseFrequency(this.getValue('swFreqInput'));
      if (!freqQuery) {
        tbody.innerHTML = `<tr><td colspan="8" class="swEmpty">Enter a frequency (kHz or MHz).</td></tr>`;
        summary.textContent = '0 results';
        return;
      }

      const tol = this.getNumber('swTol', 2);
      const onlyActive = this.getChecked('swFreqOnlyActive');

      results = this.entries.filter((e) => {
        const f = Number(e.freq);
        if (!Number.isFinite(f)) return false;
        if (Math.abs(f - freqQuery.khz) > tol) return false;
        if (hideUtil && this.isUtility(e)) return false;
        if (text && !this.matchesText(e, text)) return false;
        if (onlyActive && !this.isEntryActive(e, query.utcDayIndex, query.utcMinutes)) return false;
        return true;
      });

      results.sort((a, b) => {
        const af = Number(a.freq) || 0;
        const bf = Number(b.freq) || 0;
        if (af !== bf) return af - bf;
        const as = Number(a.start) || 0;
        const bs = Number(b.start) || 0;
        if (as !== bs) return as - bs;
        return String(a.station || '').localeCompare(String(b.station || ''));
      });

      const capped = this.capResults(results);
      this.renderRows(tbody, capped.items, query, { highlightActive: true, showBothTimes: false });

      const extra = capped.truncated ? ` (showing first ${ShortwaveModule.MAX_ROWS.toLocaleString()})` : '';
      summary.textContent = `${results.length.toLocaleString()} match${results.length === 1 ? '' : 'es'}${extra} | ${freqQuery.label}`;
      return;
    }

    // By time: what's on-air at the query instant.
    results = this.entries.filter((e) => {
      if (hideUtil && this.isUtility(e)) return false;
      if (text && !this.matchesText(e, text)) return false;
      return this.isEntryActive(e, query.utcDayIndex, query.utcMinutes);
    });

    results.sort((a, b) => {
      const af = Number(a.freq) || 0;
      const bf = Number(b.freq) || 0;
      if (af !== bf) return af - bf;
      return String(a.station || '').localeCompare(String(b.station || ''));
    });

    const capped = this.capResults(results);
    this.renderRows(tbody, capped.items, query, { highlightActive: false, showBothTimes: true });

    const extra = capped.truncated ? ` (showing first ${ShortwaveModule.MAX_ROWS.toLocaleString()})` : '';
    summary.textContent = `${results.length.toLocaleString()} on-air${extra} | ${this.formatQueryLabel(query)}`;
  }

  capResults(items) {
    if (!Array.isArray(items) || items.length <= ShortwaveModule.MAX_ROWS) return { items, truncated: false };
    return { items: items.slice(0, ShortwaveModule.MAX_ROWS), truncated: true };
  }

  renderRows(tbody, rows, query, opts = {}) {
    if (!rows.length) {
      tbody.innerHTML = `<tr><td colspan="8" class="swEmpty">No results.</td></tr>`;
      return;
    }

    const highlightActive = !!opts.highlightActive;
    const showBothTimes = !!opts.showBothTimes;

    let html = '';
    for (const e of rows) {
      const freq = Number(e.freq);
      const freqStr = Number.isFinite(freq) ? this.formatFrequency(freq) : this.escapeHtml(String(e.freq || ''));

      const daysStr = (e.days || '').trim() || 'Daily';
      const itu = (e.itu || '').trim();
      const station = (e.station || '').trim();
      const lang = (e.lang || '').trim();
      const target = (e.target || '').trim();
      const remarks = (e.remarks || '').trim();

      const isActive = this.isEntryActive(e, query.utcDayIndex, query.utcMinutes);
      const trClass = highlightActive && isActive ? 'swRowActive' : '';

      const timeCell = showBothTimes
        ? this.formatTimeCellForInstant(e, query)
        : this.escapeHtml(this.formatUtcRange(e));

      const copy = `${freqStr} kHz | ${this.formatUtcRange(e)} | ${daysStr} | ${itu} | ${station}`.trim();

      html += `
        <tr class="${trClass}" data-sw-row="1" data-copy="${this.escapeAttr(copy)}">
          <td class="swMono">${this.escapeHtml(freqStr)}</td>
          <td>${timeCell}</td>
          <td>${this.escapeHtml(daysStr)}</td>
          <td>${this.escapeHtml(itu)}</td>
          <td>${this.escapeHtml(station)}</td>
          <td>${this.escapeHtml(lang)}</td>
          <td>${this.escapeHtml(target)}</td>
          <td>${this.escapeHtml(remarks)}</td>
        </tr>
      `;
    }

    tbody.innerHTML = html;
  }

  formatQueryLabel(query) {
    if (!query || !query.date) return '';
    const d = query.date;
    const local = `${this.pad2(d.getHours())}:${this.pad2(d.getMinutes())} local`;
    const utc = `${this.pad2(d.getUTCHours())}:${this.pad2(d.getUTCMinutes())}Z`;
    return this.timeBasis === 'utc' ? utc : `${local} (${utc})`;
  }

  formatTimeCellForInstant(entry, query) {
    const win = this.getActiveWindowUtc(entry, query.date);
    if (!win) return this.escapeHtml(this.formatUtcRange(entry));

    const start = new Date(win.startMs);
    const end = new Date(win.endMs);

    const primary = this.timeBasis === 'utc'
      ? this.formatRangeFromDates(start, end, 'utc')
      : this.formatRangeFromDates(start, end, 'local');

    const secondary = this.timeBasis === 'utc'
      ? this.formatRangeFromDates(start, end, 'local')
      : this.formatRangeFromDates(start, end, 'utc');

    return `
      <div class="swTimeCell">
        <div class="swTimeMain">${this.escapeHtml(primary)}</div>
        <div class="swTimeSub">${this.escapeHtml(secondary)}</div>
      </div>
    `;
  }

  getActiveWindowUtc(entry, queryDate) {
    if (!queryDate) return null;
    const startMin = Number(entry.start);
    const endMin = Number(entry.end);
    if (!Number.isFinite(startMin) || !Number.isFinite(endMin)) return null;

    const dayStartUtcMs = Date.UTC(
      queryDate.getUTCFullYear(),
      queryDate.getUTCMonth(),
      queryDate.getUTCDate(),
      0, 0, 0, 0,
    );

    const t = queryDate.getUTCHours() * 60 + queryDate.getUTCMinutes();
    const wrap = startMin > endMin;

    if (!wrap) {
      return { startMs: dayStartUtcMs + startMin * 60000, endMs: dayStartUtcMs + endMin * 60000 };
    }

    // If we're after the start time, the window started today; otherwise, it started yesterday.
    if (t >= startMin) {
      return { startMs: dayStartUtcMs + startMin * 60000, endMs: dayStartUtcMs + 1440 * 60000 + endMin * 60000 };
    }
    return { startMs: dayStartUtcMs - 1440 * 60000 + startMin * 60000, endMs: dayStartUtcMs + endMin * 60000 };
  }

  formatRangeFromDates(startDate, endDate, basis) {
    const startHM = basis === 'utc'
      ? `${this.pad2(startDate.getUTCHours())}:${this.pad2(startDate.getUTCMinutes())}Z`
      : `${this.pad2(startDate.getHours())}:${this.pad2(startDate.getMinutes())}`;

    const endHM = basis === 'utc'
      ? `${this.pad2(endDate.getUTCHours())}:${this.pad2(endDate.getUTCMinutes())}Z`
      : `${this.pad2(endDate.getHours())}:${this.pad2(endDate.getMinutes())}`;

    const startDay = basis === 'utc'
      ? Date.UTC(startDate.getUTCFullYear(), startDate.getUTCMonth(), startDate.getUTCDate())
      : new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate()).getTime();

    const endDay = basis === 'utc'
      ? Date.UTC(endDate.getUTCFullYear(), endDate.getUTCMonth(), endDate.getUTCDate())
      : new Date(endDate.getFullYear(), endDate.getMonth(), endDate.getDate()).getTime();

    const diffDays = Math.round((endDay - startDay) / 86400000);
    const suffix = diffDays === 0 ? '' : diffDays > 0 ? ` (+${diffDays}d)` : ` (${diffDays}d)`;

    return `${startHM}–${endHM}${suffix}`;
  }

  formatUtcRange(entry) {
    const startMin = Number(entry.start);
    const endMin = Number(entry.end);
    if (!Number.isFinite(startMin) || !Number.isFinite(endMin)) return '';

    const wrap = startMin > endMin;
    const start = this.formatMinutes(startMin, true);
    const end = this.formatMinutes(endMin, true);
    return wrap ? `${start}–${end} (+1d)` : `${start}–${end}`;
  }

  formatMinutes(min, withZ) {
    const m = Math.max(0, Math.min(1440, Math.round(min)));
    const hh = Math.floor(m / 60);
    const mm = m % 60;
    const label = `${this.pad2(hh)}:${this.pad2(mm)}`;
    return withZ ? `${label}Z` : label;
  }

  formatFrequency(khz) {
    const f = Number(khz);
    if (!Number.isFinite(f)) return '';
    // Preserve decimals if present in the schedule; otherwise show as integer.
    const hasDecimal = Math.abs(f - Math.round(f)) > 1e-9;
    return hasDecimal ? String(f) : String(Math.round(f));
  }

  isUtility(entry) {
    const lang = String(entry.lang || '').trim();
    if (!lang) return false;
    return lang.startsWith('-');
  }

  matchesText(entry, q) {
    const hay = [
      entry.itu,
      entry.station,
      entry.lang,
      entry.target,
      entry.remarks,
      entry.days,
    ].join(' ').toLowerCase();
    return hay.includes(q);
  }

  isEntryActive(entry, utcDayIndex, utcMinutes) {
    const startMin = Number(entry.start);
    const endMin = Number(entry.end);
    if (!Number.isFinite(startMin) || !Number.isFinite(endMin)) return false;

    const mask = Number.isFinite(Number(entry.daysMask)) ? Number(entry.daysMask) : 127; // default daily
    const dayBit = (d) => (1 << (d % 7));
    const dayOk = (d) => (mask & dayBit(d)) !== 0;

    // Normalize end=1440 for 2400.
    const s = Math.max(0, Math.min(1440, startMin));
    const e = Math.max(0, Math.min(1440, endMin));
    const t = Math.max(0, Math.min(1439, utcMinutes));

    if (s === 0 && e === 1440) return true;

    if (s < e) {
      if (!dayOk(utcDayIndex)) return false;
      return t >= s && t < e;
    }

    // Wraps across midnight UTC.
    // Active late on the start day, or early on the next day.
    if (dayOk(utcDayIndex) && t >= s) return true;

    const prevDay = (utcDayIndex + 6) % 7;
    if (dayOk(prevDay) && t < e) return true;

    return false;
  }

  getQueryInstant() {
    const dateStr = this.getValue('swDate');
    const timeStr = this.getValue('swTime');
    if (!dateStr || !timeStr) return null;

    const m = /^(\d{4})-(\d{2})-(\d{2})$/.exec(dateStr);
    const t = /^(\d{2}):(\d{2})$/.exec(timeStr);
    if (!m || !t) return null;

    const y = Number(m[1]);
    const mo = Number(m[2]) - 1;
    const d = Number(m[3]);
    const hh = Number(t[1]);
    const mm = Number(t[2]);

    const date = this.timeBasis === 'utc'
      ? new Date(Date.UTC(y, mo, d, hh, mm, 0))
      : new Date(y, mo, d, hh, mm, 0);

    const utcMinutes = date.getUTCHours() * 60 + date.getUTCMinutes();
    const utcDayIndex = (date.getUTCDay() + 6) % 7; // Monday=0 … Sunday=6
    return { date, utcMinutes, utcDayIndex };
  }

  parseFrequency(input) {
    const raw = String(input || '').trim();
    if (!raw) return null;
    const s = raw.toLowerCase().replace(/,/g, '');

    const numMatch = s.match(/(\d+(?:\.\d+)?)/);
    if (!numMatch) return null;
    const num = Number(numMatch[1]);
    if (!Number.isFinite(num) || num <= 0) return null;

    const isMHz = s.includes('mhz');
    const isKHz = s.includes('khz') || /\bk\b/.test(s);
    let khz = num;
    if (isMHz) khz = num * 1000;
    else if (!isKHz && num < 1000) khz = num * 1000;

    const rounded = Math.round(khz * 1000) / 1000;
    const label = `${rounded} kHz`;
    return { khz: rounded, label };
  }

  copyToClipboard(text) {
    const t = String(text || '');
    if (!t) return;
    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(t).then(
        () => { try { window.radioApp.updateStatus('Copied to clipboard'); } catch (_) {} },
        () => { try { window.radioApp.updateStatus('Copy failed'); } catch (_) {} },
      );
      return;
    }

    // Fallback: best-effort using a temporary textarea.
    try {
      const ta = document.createElement('textarea');
      ta.value = t;
      ta.setAttribute('readonly', 'true');
      ta.style.position = 'fixed';
      ta.style.left = '-9999px';
      document.body.appendChild(ta);
      ta.select();
      document.execCommand('copy');
      ta.remove();
      try { window.radioApp.updateStatus('Copied to clipboard'); } catch (_) {}
    } catch (_) {
      try { window.radioApp.updateStatus('Copy failed'); } catch (_) {}
    }
  }

  pad2(n) {
    return String(Math.floor(Number(n) || 0)).padStart(2, '0');
  }

  getValue(id) {
    const el = document.getElementById(id);
    return el ? String(el.value || '') : '';
  }

  getNumber(id, fallback) {
    const el = document.getElementById(id);
    const v = el ? Number(el.value) : Number(fallback);
    return Number.isFinite(v) ? v : Number(fallback);
  }

  getChecked(id) {
    const el = document.getElementById(id);
    return !!(el && el.checked);
  }

  escapeHtml(s) {
    return String(s || '')
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/\"/g, '&quot;')
      .replace(/'/g, '&#39;');
  }

  escapeAttr(s) {
    // Safer attribute escaping for data-copy.
    return this.escapeHtml(String(s || '')).replace(/\r?\n/g, ' ').trim();
  }
}
